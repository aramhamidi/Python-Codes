git diff <Commit ID old> <Commit ID new>
	Compare two commits, printing each line that is present in one commit but not the other.
	git diff will do this. It takes two arguments - the two commit ids to compare.
	git diff considers the first argument as the "original", and the second argument
	as the "new" version, so additions are lines present in the second argument but
	not the first. this command is comparing commits inside the repository not local
	working directory.


git clone
	Make a copy of an entire Git repository, including the history, onto your own computer.
	git clone will do this. It takes one argument - the url of the repository to copy. 
	The history of changes to the directory or repository is copied.
	The state of every file in the directory or repository is copied.


git checkout
	Temporarily reset all files in a directory to their state at the time of a specific commit.
	git checkout will do this. It takes one argument - the commit ID to restore. 
	Also if your HEAD is 'detached' from when you checked out an old commit you can fix that,by
	runing the command git checkout master. 
	You can checkout a branch using this command just like checkout a commit, but each branch 
	has a more human friendly name rather than a ID.


git log (--graph) (--online) (branch name1) (branch name2) ...(branch name n)
	Show the commits made in this repository, starting with the most recent.
	git log will do this. It doesn't take any arguments.
	(--graph) Shows it as a graph
	(--online) makes it more shorter
	(branchnames) provides logs of those branches only.

git diff
	Compares the files that are staged with the files in working directory. No arguments
	should be provided.

git diff --stage
	Compares the files in staging area with the most recent commit in repository.

git reset --hard
	Disgards all the changes you made in files of your local working directory AND the
	staging area. 
	NOTE: Be very careful using this command, it is undoable! Cause you will lose all the
	changes you made in local working directory and staging area. Those changes were not 
	commited yet, so git doesn't have a snapshot of them. you do git reset --hard, you lose
	the changes for ever.

git branch
	Shows all the current branches.

git branch <New Branch Name>
	Creates a new branch named "New Branch Name"

git checkout -b <New Branch Name>
	this command combines two commands: 
		git branch <New Branch Name>
		git checkout <New Branch Name>

git gc
	If a branch is deleted and leaves some commits unreachable from existing branches, those
	commits will continue to be accessible by commit id, until Gitâ€™s garbage collection runs.
	This will happen automatically from time to time, unless you actively turn it off.
	You can also run this process manually with git gc.

git merge <branch1> <branch2>
	This command merges branch 2 into branch 1. The order doesn't matter.The key is to remember
	that git merge always merges all the specified branches into the currently checked out branch,
	creating a new commit for that branch.
	If you have already checked out branch1, you can easily say git merge branch2 to do the
	same thing. but it is always a good idea to use both, just to know what branch you are
	merging into which branch.
	Commits from branch2 will be reachable from branch1. After the merge the HEAD is on branch1.
	Merge creates a new commit(Node) with multiple parents, and the label will be the one that 
	you have checked out! That is why sometimes HEAD can be ahead of master I guess.

git show commit_id
	The command is to compare a commit to its parent.